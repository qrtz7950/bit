1교시

유연성을 위해 상속을 사용한다

추상 클래스는 프로그램 작성 시 변화에 둔감한 프로그램을 만들기 위해서 상속이 강제되는 클래스가 추상클래스다

일종의 양식을 만드는 것

추상클래스에는 바디가 없이 메소드의 정의만 되어 있다 단지 형식만 정해져 있는것이다

그래서 추상 클래스 그 자체로는 객체를 생성할 수 없기때문에 추상 클래스를 상속한 sub클래스를 만들어서 오버 라이딩 해야한다

오버라이딩은 단지 추상클래스와 서브 클래스간의 관계에서만 있는것은 아니지만 추상클래스를 이용하여 오버라이딩을 강제한다

※오버라이딩 : 
부모클래스에서 상속받은 서브 클래스의 메소드의 기능을 바꾸거나
상속받은 부모 클래스가 추상 클래스일 경우 메소드의 기능을 구현하는것

추상클래스를 상속받은 서브클래스의 경우에는

추상클래스의 객체변수는 하위클래스로 가질수있다

부모 클래스 Print 서브클래스 LgPrinter일 때 LGprinter의 객체를 만들고 싶다

Printer p = new LgPrinter();
LgPrinter p = new LgPrinter();

둘다 가능하다 기능은 조금 다르다 그건 나중에

------------------------------------------------------------------------------------------
5교시

객체지향언어의 특징

자바 병신이야 C#으로 해야지
자바로 만든 클래스가 어떤 특징을 가지고 있는가?
이것을 표현하기 위해서 누구나 봐도 알아볼수있는 객체를 표현해 모델링을 하고 싶었다
이거시바로 uml

C++ C#은 star uml을 사용하나 자바는 연동이 안됨

아마테라스를 이용 uml작성 예제 실습

------------------------------------------------------------------------------------------
6교시

객체형변환
1. 정의 : "=" 연산자를 기준으로 좌변과 우변의 데이터 타입이 다른 경우에 발생
2. 조건 : 좌변과 우변의 객체가 상속 관계가 있어야 함

객체형변환을 이용하면 좀더 둔감한 코드를 작성할 수 있고
최종적으로 추상 클래스와 객체형 변환을 같이써야 완전 둔감한 프로그램을 만들 수 있다

상속관계에 있는 두 클래스를 객체를 

형변환할 때 큰 타입을 작은 타입으로 변환하면 다운캐스팅 (묵시형 객체 형변환)
형변환할 때 작은 타입을 큰 타입으로 변환하면 업캐스팅 (명시형 객체 형변환)

상속을 받아 상위 클래스 하위 클래스 인스턴트 객체가 모두 있는 하나의 인스턴트 객체에서
묵시적 객체형변환으로 Printer p = new LGPrinter ( );하면 더 큰 타입을 작은 타입으로 변환하는 묵시형 형변환이 일어난다.

이 경우 Print형 인스턴트 객체 p가 상속받은 상위 클래스의 Print에 정의된 멤버변수와 메소드만 사용할 수 있다.
그렇지만 이 둘은 상속관계이기때문에 p.info()로 메소드를 호출하게되면 하위 클래스에 오버라이딩된 메소드가 호출된다
교재 106번째 슬라이드 참조

결국 부모형 객체 변수로 하위 메소드를 이용할 수 있다는 장점이 있다
자식형 객체변수를 사용하지 않음으로 코드에 사용되는 메소드들의 변수를 통일할 수 있다

묵시형 명시형변환 예제

----------------------------------------------------------------------------------------------
7교시

객체지향적 프로그래밍을 하다보니 여러 클래스들의 메소드들이 동시에 필요한 객체를 만들어야했지만
상속은 한개의 클래스만 가능하기때문에 (단일 상속) 추상메소드들의 집합인 인터페이스가 등장했다.

인터페이스 추상메소드들의 집함
들어갈수 있는것은 추상메소드와 상수





