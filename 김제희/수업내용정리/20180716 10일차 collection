같은 타입의 자료들을 메모리에 어떻게 하면 좀 더 효율적으로 저장할 수 있을까
이는 자료 구조와 관련되어 있지만 알고리즘을 공부하지않고도 collecton api를 이용하여 좀더 효율적인 메모리 사용이 가능하다

종류는

저장 알고리즘
탐색 알고리즘이 있다

배열은 참조, 기본 자료형 둘다 만들 수 있다
그러나 같은 자료형만을 모아둔 집합

콜렉션은 모두다 참조자료형이기때문에 기본 자료형을 가지기위해
이런 기본자료형을 멤버변수로 가지고있는 객체 자료형이 따로있다
기본 자료형을 감싸고 있는 참조자료형이기 때문에 wrapper class 라고한다

ex) int[] ====> Integer[]

잠조자료형은 기본자료형을 가질 수 없으나 1.5버젼 이후부터

int i = 10;
integer i2 = new integer(10)
integer i3 = 10; //interger = int
이런 코드는 원래 에러가 나나 객체에서 내용물을 자동으로 뽑아 넣어준다
이런 개념을 auto boxing이라고 한다

-정적 자료구조
고정된크기의 자료구조
배열이 대표적인 정적 자료구조
선언시 크기를 명시하면 바꿀 수 없음

-동적 자료구조
요소의 개수에 따라 자료구조의 크기가 동적으로 증가하거나 감소
벡터 리스트 스택 큐등

자료구조들의 종류응 결국 어떤 구조에서 얼마나 빨리 원하는 데이터를 찾는가에 따라 결정된다

순서를 유지할 것인가?                                    //셋
중복을 허용할 것인가?                                    //리스트
다른 자료구조들에 비해서 어떤 단점과 정점을 가지고 있는가?  //큐
콜렉션은 아니지만 더 빠른 검색을 위해 맵이라는 클래스도 있다

배열은 같은 자료형의 값 집합
콜렉션은 객체들의 집합

모든 클래스들은 오브젝트를 상속하므로 Object[]라고할수있다

ex)Object[] {new String("aaa"),new Random, new Integer(100). new CalendarUtil()}

그러나 이 경우에는 Object에서 오버라이딩하는 메소드만 이용이 가능해지기때문에
각 객체의 메소드를 이용하기위해 명시적 형변환을 해봐야하나 명시적 형변환은
어떤 주소 번지에 어떤 객체가 들어있는지 모르므로 명시적 변환도 애매해진다

배열의 경우에는 같은 타입의 자료만 저장되기때문에 이런 문제가 없었는데 콜렉션은 이런 문제가 발생

때문에 Generic이 등장하였다.
콜렉션에 객체를 넣을 때부터 이 객체가 어떤 타입인지를 알수 있게해주는 Generic문법을 사용하였다.
자바 권고사항으로도 콜렉션 사용시 제너릭 문법을 사용하여 명시해야함

List
순서가 있고 중복을 허용 (배열과 유사)
그러나 배열과 다르게 길이가 가변적인 배열이다
단점 원하는 데이터가 뒤쪽에 위치하는 경우 속도의 문제
특징 인터페이스임  메소드의 이름은 고정되어있다

ArrayList   메모리상에서 연속적인 공간
LinkedList  메모리상에서 비연속적인 공간이지만 각 객체들이 연속적인 데이터인것처럼 사용

요즘은 다 db써서 잘 안씀

ex)
new ArrayList<Integer>; //Integer형을 모아둔 객체들의 집합이다라는 뜻
//제너릭 사용예제
//ArrayList는 제너릭을 사용할 수도 그렇지 않을수도있다
ArrayList list new ArrayList();
ArrayList<String> list new <Sting>ArrayList();
//윗줄은 오브젝트 객체의 집합
//아랫줄은 스트링형 값만을 가지는 객체의 집합

ArrayList - 메소드

new ArrayList<String>이 되어있을때
list.add("봄")                     //순차적으로 리스트에 추가됨
list.add("여름")
String val = list.get( 0 );         //봄이 반환
list.size( )                        //2를반환
list.remove(0);                     //0번지를 삭제하고 1번지를 0번지로 바꿈(전체적으로 밀어줌)
list.remove(“봄”);                  //해당 데이터 삭제
list.clear( );                      //몽땅 다 지움
boolean b = list.contains(“봄” );   //불린형으로 포함했는지를 반환
boolean b = list.isEmpty();         //데이터가 번지수에 존재하는지 체크
list.addAll( sub );                 //기존에 존재하는 콜렉션을 복사하여 맨뒤번지수에 붙여넣음 (삭제X)


이뉴물레이터 =비슷= 이터레이터

맨처음부터 맨 마지막까지 모든 데이터를 접근하는애를 순환자라고한다

-------------------------------------------------------------------------------
6교시
-----------set-------------
list와는 다르다 list와는!

순서가 없고 중복을 허용하지않음

장점: 빠른속도
단점: 단순 집합의 개념으로 정렬하려변 별도의 처리가 필요하다

구현 클래스
-HashSet //주소값 사전순정렬
-TreeSet //값 사전순정렬

Map

특징 : Key(키)와 Value(값)으로 나누어 데이터 관리, 순서는 없으며, 키에 대한
중복은 없음
➢ 장점 : 빠른 속도
➢ 구현 클래스
▪ HashMap
▪ TreeMap

객체에서 중복인 객체를 검사할때 객체끼리 비교하면 값은 같을지모르나
다른 객체로 만들어 졌기때문에 멤버변수를 가리키는 객체들은 서로 다른 주소값을 가진다
java는 객체의 hashcode값과 value가 둘다 같아야 같은 값이라고 인식하기때문에
다른 객체의 같은 값이 같냐고 물어보더라도 hashcode의 차이때문에 다르다고 인식한다
때문에 hashcode값과 value값을 모두 비교할수 있도록 equals와 hashcode 메소드를 오버라이드하여
둘을 비교할 수 있도록 메소드를 수정해야한다















